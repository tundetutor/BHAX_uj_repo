<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Mandelbrot!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section xml:id="bhax-textbook-feladatok-mandelbrot.Mandelbrot">
        <title> A Mandelbrot halmaz</title>
        <para>
            Írj olyan C programot, amely kiszámolja a Mandelbrot halmazt!     
        </para>
        <para>
            Ebben a feladatban Czanik Andrást tutoriáltam.    
        </para>
        
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            A Mandelbrot halmazt 1980-ban találta meg Benoit Mandelbrot a 
            komplex számsíkon. Komplex számok azok a számok, amelyek körében 
            válaszolni lehet az olyan egyébként értelmezhetetlen kérdésekre, 
            hogy melyik az a két szám, amelyet összeszorozva -9-et kapunk, 
            mert ez a szám például a 3i komplex szám. 
        </para>

        <para>             
            A Mandelbrot halmazt úgy láthatjuk meg, hogy a sík origója középpontú 4 
            oldalhosszúságú négyzetbe lefektetünk egy, mondjuk 800x800-as 
            rácsot és kiszámoljuk, hogy a rács pontjai mely komplex számoknak 
            felelnek meg. A rács minden pontját megvizsgáljuk a 
            z<subscript>n+1</subscript>=z<subscript>n</subscript>
            <superscript>2</superscript>+c, 
            (0&lt;=n) képlet alapján úgy, hogy a c az éppen vizsgált rácspont. 
            A z0 az origó. Alkalmazva a képletet a 
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    z<subscript>0</subscript> = 0
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>1</subscript> = 0<superscript>2</superscript>+c = c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>2</subscript> = c<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>3</subscript> = (c<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    z<subscript>4</subscript> = ((c<superscript>2</superscript>+c)<superscript>2</superscript>+c)<superscript>2</superscript>+c
                </para>
            </listitem>
            <listitem>
                <para>
                    ... s így tovább.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Azaz kiindulunk az origóból (z<subscript>0</subscript>) 
            és elugrunk a rács első pontjába a z<subscript>1</subscript> = c-be, 
            aztán a c-től függően a további z-kbe. Ha ez az utazás kivezet a 
            2 sugarú körből, akkor azt mondjuk, hogy az a vizsgált rácspont 
            nem a Mandelbrot halmaz eleme. Nyilván nem tudunk végtelen sok 
            z-t megvizsgálni, ezért csak véges sok z elemet nézünk meg minden 
            rácsponthoz. Ha eközben nem lép ki a körből, akkor feketére 
            színezzük, hogy az a c rácspont a halmaz része. (Színes meg úgy 
            lesz a kép, hogy változatosan színezzük, például minél későbbi 
            z-nél lép ki a körből, annál sötétebbre). 
        </para>      
        <para>
            A feladat leírását azzal szeretném kezdeni, hogy a feladatban tárgyalt kód Bátfai Norberté és ez egy C++ 
            kód, mivel nem sikerült megfelő <command>libpng</command> könyvtárat telepítenem C nyelvhez. Mivel a kód 
            nem használja a komplex osztályt ezért úgy kell gondolkodni mintha azt magunk akarnánk létrehozni.
        </para> 
        <para>   
            A program maga a Mandelbrot halmazt rajzolja ki a komplex számsíkon. A Mandelbrot-halmaz volt az egyik első olyan fraktál alakzat amit felfedeztek. 
            A fraktáloknak jelenleg még nincsen konkrétan megfogalmazott szigorú matematikai definíciója mivel a definíció megalkotásakor mindig valamilyen ellentmondásba ütközünk.
            Ahogy jellemezni tudjuk őket, önhasonló alakzatok, azaz ha bizonyos részeikre ránagyítunk, mint a Mandelbrot-halmaz határterületei esetén is, az eredti alakzatot 
            kapjuk vissza ezáltal egy végteleül összetett struktúrát alkotva. A nevüket a latin "fractus" azaz töredzettség szóból származtatjuk ami a fraktálalakzatok határterületein 
            megjelenő matematikailag nehezen leírható önismétlődésre utal, mivel ezáltal nem jön létre tényleges határvonal például a Mandelbrot halmaz esetén sem.
            Viszont a természet nagyon sok fraktálszerű önhasonló struktúrában rendeződik, 
            ilyen például a hegyek csipkézettsége, a növények növekedési logikája, vagy éppen a villámok is. Az álatalam egyik generált kép nekem pont a villámok által
            alkotott alakzatokat jutatta eszembe, ezért ezt az ábrát ide illesztem.
        </para>

        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/villám.png" format="PNG" scale="40" />
            </imageobject>
        </mediaobject> 

        <para>
            A program a <command>png++/png.hpp</command> könyvtár meghívásával kezdődik, ez szükséges ahhoz, hogy png-t tudjunk generálni.
            Ezután definiáljuk a szükséges konstansokat, ezek közül az N és az M határozzák meg, hogy mekkora méretű legyen az elkészült png. 
            Én ezeket duplájukra, azaz 1000-re növeltem hogy élesebb képet kaphassunk., ha ettől nagyobb számra növeljük, például 2000-re, szegmentálási 
            hiba léphet fel, óvatosa kell kiválasztani a számot. Ezen kívűl szükségünk van a maximum illetve minimum x és y értékekre.
        </para> 
        <programlisting language="c++">
<![CDATA[

#include <png++/png.hpp>

#define N 1000
#define M 1000
#define MAXX 0.7
#define MINX -2.0
#define MAXY 1.35
#define MINY -1.35
]]>
        </programlisting> 
        <para>
            A következő fontos része a programunknak egy eljárás, viszont ez a program legvégén hívódik meg ezért ezt ott fogom kifejteni.
        </para>
      
        <para>
            Ahhoz, hogy a komplex osztály nélkül tudjunk a komplex számsíkon dolgozni a programban létre kell hozni a komplex struktúrát.
            Ezzel tudjuk a komplex számainkat valós (re) és imaginárius (im) egységre bontani. Ezután a főprogramban létrehozunk egy <command>N*M</command> elemű 
            kétdimenziós tömböt, ebbe fogjuk eltárolni, hogy a png mely léppontjai milyen színűek legyenek. A színek meghatározásához létrehozunk
            egy <command>iteracio</command> nevű változót. A program végigmegy a tömbön két for ciklussal amiben található egy while ciklus. 
            A while ciklus maximum 256 alkalommal futhat le és közben az <command>iteracio</command> változóban számoljuk a futások számát. amennyiben az iteráció 
            256 alkalommal futott le az azt jelenti, hogy az adott érték nem tudott kilépni a Mandelbrot halmazból, annak része tehát a pixel fekete lesz az ábrán.
        </para>
        <programlisting language="c++">
<![CDATA[ 
struct Komplex
{
    double re, im;
};

int main()
{
    int tomb[N][M];

    int i, j, k;

    double dx = (MAXX - MINX) / N;
    double dy = (MAXY - MINY) / M;

    struct Komplex C, Z, Zuj;

    int iteracio;

    for (i = 0; i < M; i++)
    {
        for (j = 0; j < N; j++)
        {
            C.re = MINX + j * dx;
            C.im = MAXY - i * dy;

            Z.re = 0;
            Z.im = 0;
            iteracio = 0;

            while(Z.re * Z.re + Z.im * Z.im < 4 && iteracio++ < 255)
            {
                Zuj.re = Z.re * Z.re - Z.im * Z.im + C.re;
                Zuj.im = 2 * Z.re * Z.im + C.im;
                Z.re = Zuj.re;
                Z.im = Zuj.im;
            }

            tomb[i][j] = iteracio - 1;//1 - iteracio; //256 - iteracio 
        }
    }

    GeneratePNG(tomb);

    return 0;
}
        ]]>
        </programlisting> 
        <para>
            A pixelek színének meghatározása tehát az iterációtól függ. én módosítottam egy kicsit a programon, az alap programban maga a halmaz fekete színű, 
            ekkor a főprogram utolsó sorában a <command>tomb[i][j] = 256 - iteracio;</command> kifejezés szerepel. Viszont ha változtatunk ezen az értékadáson 
            <command>tomb[i][j] = iteracio - 1;</command>-re akkor az eredi inverzét kapjuk. Ha az iterációk számából vonunk ki 256-ot akkor pedig 
            a halmaz maga is fekete lesz és az eredi program által rajzolt ábra beli részek is feketék lesznek viszont a halmaz közvetlen környezete fehér vagy nagyon világos 
            szürkés színű. 
        </para>
        <programlisting language="c++">
<![CDATA[  
void GeneratePNG( int tomb[N][M])
{
    png::image< png::rgb_pixel > image(N, M);
    for (int x = 0; x < N; x++)
    {
        for (int y = 0; y < M; y++)
        {
            image[y][x] = png::rgb_pixel(tomb[x][y], tomb[x][y], tomb[x][y]); //x y
        }
    }
    image.write("kimenet.png");
}
]]>
        </programlisting> 
        <para>
            A program utolsó része a png generáló eljárás, itt is 2 for ciklus segítségével megyünk végig a kétdimenziós tömbön és megadjuk a pixelek értékét színbeli értékét.
            Én itt is módosítottam kicsit a képen ugyanis elforgattam, ehhez annyit kell tennünk hogy a pixelek értékadásánál az <command>x</command> és <command>y</command>-t felcseréljöük.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/mandel_3.jpg" format="JPG" scale="17" />
            </imageobject>
        </mediaobject>  

    </section>        
        
    <section>
        <title>A Mandelbrot halmaz a <filename>std::complex</filename> osztállyal</title>
        <para>
            Írj olyan C++ programot, amely kiszámolja a Mandelbrot halmazt!                     
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        
        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/mlkomplex.png" format="PNG" scale="55" />
            </imageobject>
        </mediaobject>    

        <para>
            A C++ sok változást hozott a C-vel szemben, több beépített osztályt és beépített függvényt találunk benne. 
            Ezek között szerepel az <filename>std::complex</filename> osztály is. Az előző feladatban a programban magunk hoztuk létre 
            a komplex struktúrát most viszont ki is használjuk a C++ előnyeit. A program maga szinte megegyezik az előző feladatban tárgyalttal, 
            ez is Bátfai Norbert által írt program. Vizsgáljuk meg a különbségeket!          
        </para>
        <para>
            Az első fontos különbség, hogy a <command>png++/png.hpp</command> könyvtár meghívása után egyből meghívjuk a <command>complex</command> 
            osztályt, ez a C++ beépített osztálya a komplex számokkal való kényelmesebb munkához. A <command>GeneratePNG</command> eljárás is megegyezik 
            az előző feladatban tárgyalttal ezért annak leírását ott lehet megtekinteni.
        </para>
        
        <programlisting language="c++">
<![CDATA[#include <png++/png.hpp>
#include <complex>

const int N = 500;
const int M = 500;
const double MAXX = 0.7;
const double MINX = -2.0;
const double MAXY = 1.35;
const double MINY = -1.35;

void GeneratePNG(const int tomb[N][M])
{
    png::image< png::rgb_pixel > image(N, M);
    for (int x = 0; x < N; x++)
    {
        for (int y = 0; y < M; y++)
        {
            image[x][y] = png::rgb_pixel(tomb[x][y], tomb[x][y], tomb[x][y]);
        }
    }
    image.write("kimenet.png");
}

]]>
        </programlisting>
        <para>
            A legnagyobb különbség persze a főprogramunkban van, azon belül is abban a részben, ahol a Mandelbrot-halmazt számoltatjuk a programmal. 
            A matematikai háttere ugyanaz a két programnak csupán a komplex számokkal való folyamatok térnek el. Az előző programban ehhez egy struktúrát 
            használtunk, mégpedig olyat, hogy két részre bontottuk a komplex számokat, valós és imaginárius egységre. Ennek a leegyszerűsétésére szolgál a 
            komplex osztály, ugyanis egy értékadással tudunk értéket adni a C és Z számoknak, nem kell a két részüket külön kezelni mint az előző esetben ezáltal 
            egy keveset rövidül is a program. Mivel a kép generálása és a pixelek színének meghatározásának folyamata egyezik az előző feladatban tárgyaltéval a 
            részletesebb leírást ott lehet megtalálni.
        </para>

        <programlisting language="c++">
<![CDATA[
int main()
{
    int tomb[N][M];

    double dx = ((MAXX - MINX) / N);
    double dy = ((MAXY - MINY) / M);

    std::complex<double> C, Z, Zuj;

    int iteracio;

    for (int i = 0; i < M; i++)
    {
        for (int j = 0; j < N; j++)
        {
			C = {MINX + j * dx , MAXY - i * dy};

            Z = 0;
            iteracio = 0;

            while(abs(Z) < 2 && iteracio++ < 255)
            {
                Zuj = Z*Z+C;
                Z = Zuj;
            }

            tomb[i][j] = 256 - iteracio;
        }
    }

    GeneratePNG(tomb);

    return 0;
}

]]>
        </programlisting>  

        

        <para>
            Nézzük meg hogyan néz ki a az értékadása egy komplex számnak az előző feladatban tárgyalt struktúrával: 
            <screen>
            C.re = MINX + j * dx;
            C.im = MAXY - i * dy;
            </screen>
            És nézzük meg ezt az <filename>std::complex</filename> osztállyal is:
            <screen>
            C = {MINX + j * dx , MAXY - i * dy};
            </screen>
        </para>
        <para>
            A menta-lila színű halmazhoz használt színezéshez a <command>void GeneratePNG</command>-ben a következő sort így módosítottam:
            <screen>
                image[y][x] = png::rgb_pixel(76, tomb[x][y], 146);
            </screen>
            Illetve ismét megcseréltem az x és y tengelyt, hogy az y tengelyre legyen szimmetrikus a halmaz, szerintem így kellemesebb a szemnek 
            a függőleges szimmetria tengely miatt.
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/komplex2.jpg" format="JPG" scale="25" />
            </imageobject>
        </mediaobject>  
    </section>        
                
    <section>
        <title>Biomorfok</title>
        <para>
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/IJMbgRzY76E">https://youtu.be/IJMbgRzY76E</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/Biomorf</link>
        </para>
        <para>
            A biomorfokra (a Julia halmazokat rajzoló bug-os programjával) 
            rátaláló Clifford Pickover azt hitte természeti törvényre 
            bukkant: <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link> (lásd a 2307. oldal aljától).
        </para>       
        <para>
            A különbség a <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmaz</link>
            és a Julia halmazok között az, hogy a komplex iterációban az előbbiben a c változó, utóbbiban pedig állandó. 
            A következő Mandelbrot csipet azt mutatja, hogy a c befutja a vizsgált összes rácspontot.
        </para>  
        <para>
            Tehát ha a Júlia halmazokról beszélünk az azt jelenti, hogy a Mandelbrot-halmaz részhalmazait vesszük. Mivel most mi választjuk a C-t konstansnak végtelen mennyiségű 
            ilyen halmazt találhatunk, mivel a konstansok száma végtelen. A program komplex iterációját számító részének logikája nem változik, azért kapunk más képet 
            mert itt a C-t előre megadjuk. 
        </para>       
        <figure>
            <title>A <type>Júlia </type> halmazokat ábrázoló szemléletes ábra a <link xlink:href="https://www.facebook.com/groups/Fractalgasm/">Fractalgasm</link> Facebok csoportból</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="img/julias.jpg" scale="50" />
                </imageobject>
                <textobject>
                    <phrase></phrase>
                </textobject>
            </mediaobject>
        </figure> 
        <programlisting language="c++">
<![CDATA[  // j megy a sorokon
  for ( int j = 0; j < magassag; ++j )
    {
      for ( int k = 0; k < szelesseg; ++k )
        {

          // c = (reC, imC) a halo racspontjainak
          // megfelelo komplex szam

          reC = a + k * dx;
          imC = d - j * dy;
          std::complex<double> c ( reC, imC );

          std::complex<double> z_n ( 0, 0 );
          iteracio = 0;

          while ( std::abs ( z_n ) < 4 && iteracio < iteraciosHatar )
            {
              z_n = z_n * z_n + c;

              ++iteracio;
            }
]]>
        </programlisting>        
        <para>
            Ezzel szemben a Julia halmazos csipetben a cc nem változik, hanem minden vizsgált
            z rácspontra ugyanaz.
        </para>
        <programlisting language="c++">
<![CDATA[    // j megy a sorokon
    for ( int j = 0; j < magassag; ++j )
    {
        // k megy az oszlopokon
        for ( int k = 0; k < szelesseg; ++k )
        {
            double reZ = a + k * dx;
            double imZ = d - j * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {
                z_n = std::pow(z_n, 3) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }
]]>
        </programlisting>                         
        
        <para>
            A biomorfok nevüket arról kapták, hogy amikor felfedézték őket rengeteg olyan alakzatot találtak amelyek természetben megtalálhatóak, mint például 
            a sejtek is ezzel szemben az általam kirajzoltatott kép inkább hasonlít valamilyen szigoróa meghatározott geometriai alakzatra. De a feladatmegoldás végén 
            mindenképp szemléltetem miről van szó.
        </para>
            

        <para>
            A bimorfos algoritmus pontos megismeréséhez ezt a cikket javasoljuk: 
            <link xlink:href="https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf">https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf</link>.
            Az is jó gyakorlat, ha magából ebből a cikkből from scratch kódoljuk be a sajátunkat, de mi a királyi úton járva a 
            korábbi <link xlink:href="#bhax-textbook-feladatok-mandelbrot.Mandelbrot">Mandelbrot halmazt</link> kiszámoló 
            forrásunkat módosítjuk. Viszont a program változóinak elnevezését összhangba hozzuk a közlemény jelöléseivel:
        </para>       
        <programlisting language="c++">
<![CDATA[// Verzio: 3.1.3.cpp
// Forditas:
// g++ 3.1.3.cpp -lpng -O3 -o 3.1.3
// Futtatas:
// ./3.1.3 bmorf.png 800 800 10 -2 2 -2 2 .285 0 10
// Nyomtatas:
// a2ps 3.1.3.cpp -o 3.1.3.cpp.pdf -1 --line-numbers=1  --left-footer="BATF41 HAXOR STR34M" --right-footer="https://bhaxor.blog.hu/" --pro=color
// 
// BHAX Biomorphs
// Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
// Version history
//
// https://youtu.be/IJMbgRzY76E
// See also https://www.emis.de/journals/TJNSA/includes/files/articles/Vol9_Iss5_2305--2315_Biomorphs_via_modified_iterations.pdf
//

#include <iostream>
#include "png++/png.hpp"
#include <complex>

int
main ( int argc, char *argv[] )
{

    int szelesseg = 1920;
    int magassag = 1080;
    int iteraciosHatar = 255;
    double xmin = -1.9;
    double xmax = 0.7;
    double ymin = -1.3;
    double ymax = 1.3;
    double reC = .285, imC = 0;
    double R = 10.0;

    if ( argc == 12 )
    {
        szelesseg = atoi ( argv[2] );
        magassag =  atoi ( argv[3] );
        iteraciosHatar =  atoi ( argv[4] );
        xmin = atof ( argv[5] );
        xmax = atof ( argv[6] );
        ymin = atof ( argv[7] );
        ymax = atof ( argv[8] );
        reC = atof ( argv[9] );
        imC = atof ( argv[10] );
        R = atof ( argv[11] );

    }
    else
    {
        std::cout << "Hasznalat: ./3.1.2 fajlnev szelesseg magassag n a b c d reC imC R" << std::endl;
        return -1;
    }
    ]]>
        </programlisting> 
        <para>
            Ha a fenti kódcsipetet vizsgáljuk láthatjuk, hogy a program a futtatása során 11 argumentumot vár, ezek között a 
            9-es a C valós részét jelenti, a 10-s pedig az imaginárius egységes, azaz a programon belül bárhogy választhatunk konstanst, nem fogja 
            befolyásolni a kirajzolt képet, viszont, ha a program makefile-jában ezeket az argumentumokat módosítjuk az már változtat rajta. Illetve 
            a makefile módosításával befolyásolhatuk a kirajzolandó kép méretét is. Én az alábbi argumentumokat adtam meg a keletkezett képhez:
            <screen>
            @./biomorf bmorf.png 8000 8000 10 -3 3 -3 3 18.5 -15.45 10
            </screen>
            melyekből a C-t befolyásoló értékek a következők:
            <screen>
            18.5 -15.45 
            </screen>
            Illetve fontos megjegyezni, hogy én elég nagy felbontással dolgoztam, ezt a fentebbi sorból a 8000 8000 argumentumok takarják, 
            tehát az én képem 8000*8000 pixeles felbontásban jelenik meg. 
        </para>

    <programlisting language="c++">
<![CDATA[// Verzio: 3.1.3.cpp  
    png::image < png::rgb_pixel > kep ( szelesseg, magassag );

    double dx = ( xmax - xmin ) / szelesseg;
    double dy = ( ymax - ymin ) / magassag;

    std::complex<double> cc ( reC, imC );

    std::cout << "Szamitas\n";

    // j megy a sorokon
    for ( int y = 0; y < magassag; ++y )
    {
        // k megy az oszlopokon

        for ( int x = 0; x < szelesseg; ++x )
        {

            double reZ = xmin + x * dx;
            double imZ = ymax - y * dy;
            std::complex<double> z_n ( reZ, imZ );

            int iteracio = 0;
            for (int i=0; i < iteraciosHatar; ++i)
            {

                z_n = std::pow(z_n, 3) + cc;
                //z_n = std::pow(z_n, 2) + std::sin(z_n) + cc;
                if(std::real ( z_n ) > R || std::imag ( z_n ) > R)
                {
                    iteracio = i;
                    break;
                }
            }

            kep.set_pixel ( x, y,
                            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
        }

        int szazalek = ( double ) y / ( double ) magassag * 100.0;
        std::cout << "\r" << szazalek << "%" << std::flush;
    }

    kep.write ( argv[1] );
    std::cout << "\r" << argv[1] << " mentve." << std::endl;

}
]]>
        </programlisting>   
        <para>
            Én a program színezését is módosítottam amit itt is hasonlóan lehet megtenni mint az előző programok esetében tehát a 
            <screen>
            png::rgb_pixel ( (iteracio*20)%255, (iteracio*40)%255, (iteracio*60)%255 ));
            </screen>
            soron kell módsítanunk. Látható, hogy itt bonyolultabban számítjuk ki az iterációnól a színeket de ez majdhogynem mindegy 
            hogyan tesszük, a program matematikai hátterét nem befolyásolja, csak a készült png-t. Én az alábbi módosításokat tettem meg 
            a bordó-türkiz árnyalatú kép elkészítéséhez:
            <screen>
            png::rgb_pixel ( (iteracio*100)%76, (iteracio*80)%140, (iteracio*80)%122 )); 
            </screen>
            Az általam kirajzoltatott biomorf nekem azét tetszett nagyon mivel a középén található bordó háromszög szerű részek mindtha pontosan 
            60 fokos szögeket zárnának be egymással, és az ábra kinyúló részeiben ugyanez az alakzat található meg csak kisebb méretben és más színekkel.
            És nézzük meg végre a kirajzolt png képet:
        </para> 


        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/biomorf1.png" format="PNG" scale="5" />
            </imageobject>
        </mediaobject>   

        <para>
            Mint ahogy említettem én nagy felbontással dolgoztam ezért megtehettem, hogy ránagyítok a kép egyes részeire, itt már felfedezhetjük benne a 
            fraktálok önhasonló természtetét a háromszögszrű alakzatok önismétlődésében. 
        </para> 
        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/biomorfnagy.png" format="PNG" scale="40" />
            </imageobject>
        </mediaobject>           
                                                                            
    </section>                     

    <section>
        <title>A Mandelbrot halmaz CUDA megvalósítása</title>
        <para>
            Ebben a feladatban ugyanazzal a mandelbrot halmaz algoritmussal dolgozunk mint az eddigi feladatokban is viszont itt van egy nagy 
            különbség az eddigiekhez képest. Itt a feladat lényege hogy a CPU helyett a videókártya számítási kapacitását használjuk ki.
            Ahhoz hogy ezt meg tudjuk csinálni mindenképp szükségünk van egy Nvidia kártyára mivel a CUDA az Nvidia saját fejlesztése.
        </para>
        <para>
            A CUDA lényege, hogy az Nvidia kártyák rendelkeznek bizonyos mennyiségű CUDA magokkal, ezekkel 
            párhuzamosan tudunk egyszerre több számítást is végezni. A CPU is rendelkezik magokkal amellyel párhuzamos számtásokat végezhetünk
            viszont nem annyival mint egy Nvidia kártya és máshogyan is működnek, egy ilyen program esetében a CPU csak egy magot használ.
            Ahhoz hogy rávegyük a videókártyánkat a számolásra mindenképp telepítenünk kell az Nvidia Cuda Toolkitet. CUDA illesztőprogramokból 
            egyébként találhatunk többet is, ugyanis mostanában kezd egyre jobban elterjedni hogy a deep learning miatt, ami nagy számítási 
            kapacitás igényű folyamat. Véleményem szerint a CUDA a következő évkben eléggé elterjedté válhat ennek köszönhetően. 
            Viszont most nekünk az alap Nvidia Cuda Toolkit tökéletesen mgfelel.
        </para>
        <para>
            Az elképzelés az lenne hogy a png minden pixelét más szál, más CUDA mag tudja kiszámolni. Ha belegondolunk ez hatalmas újítás ahhoz 
            képest mintha ugyanezt a CPU-val szeretnénk megvaósítani. Nyílván ez a gyakorlatban nem teljesen így van hogy minden pixelre jut egy 
            szál, de a CUDA-val ehhez már közelítünk, gondoljunk bele hogy ha egy erősebb GPU-val rendelkezünk amiben közel 1200 cuda mag van
            valószínűleg a számítás ideje jóval lecsökken a CPU-hoz képest. Azt is érdemes megemlítenünk, hogy hiába van sokmagos, sokszálas erős 
            processzorunk ha egy folyamat csak 1 szálat fog használni, nem tudjuk kihasználni az egész teljesítményét míg a GPU esetén igen.
        </para>
        <para>
            Én a CUDA-t a Blenderben való Cycles rendermotorral történő rendereléshez szoktam is használni. A Blender Cycles-e is ha nem 
            rendelkezünk GPU-val processzorból fog számolni. A renderelés során egy ilyen technológia komoly napokat is megspórolhat nekünk,
            itt azért már érzi az ember, hogy valóban jelentősége van ennek. Egyébként 3D renderelés esetén hasonló dolog történik, mint a 
            mandelbrot halmaznál, csak ott nem ezt az algoritmust használjuk, hanem a 3D felületet alkotó háromszögek normálvektoraiból lehet 
            meghatározni egy-egy pixel milyen színű legyen.
        </para>
        <para>
            Nálam megcsinál egy png-t viszont az közel sem a mandelbrot hamlmaz amit kiad. Az a sejtésem hogy a hardware konfigom a baj,
            én 2 db Nvidia Quadro kártyát használok, ezek kifejezettem 3D grafikai folyamatokhoz vannak fejlesztve, viszont még nem sikerült 
            SLI hídba kötnöm őket és szerintem vagy ez okozza a gondot vagy az hogy ezek nem mai kártyák és driver probléma van. A program 
            egyébként a következő értékeket írta ki:
        </para>
        <para>
            <screen>
                13
                0.133559 sec
            </screen>
        </para>

        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/cuda_fail.png" format="PNG" scale="25" />
            </imageobject>
        </mediaobject> 

        <para>
            Akárhányszor futattom mindig csak hanygafocit rajzol a program. Szerencsére találtam itthon egy másik gépet is (ez egyébként apáé)
            szóval arra is telepítettük a libpng-t majd futtatuk a programot. Abban a gépben egyébként egy Nvidia GTX 1060-as GPU-t találunk, 
            megfelő driverekkel és persze a CUDA Toolkit-et is már régen feltelepítettük rá. Csodák csodájára ez szépen kirajzolta a halmazt, 
            természetesen ugyanazt a programot futtatva ami nekem ezeket a furcsa zajos képeket adta. Nyílvánvaló, hogy valami probléma van az 
            iterációk számítása során. Amikor elhoztam a gépemet ezekkel a GPU-kkal tudtam, hogy kompromisszumokat kell kötnöm, 10 éves technológiáról 
            beszélünk. 
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/cuda_win.png" format="PNG" scale="35" />
            </imageobject>
        </mediaobject> 

        <para>
            Megjegyzés: az általam használt videókártyák nem mai darabok, például a Blender a 2.80-as verzójától nem támogatja tehát 
            ha a Blender rendermotorját szeretném használni akkor a 2.79-es verzióval kell dolgoznom. A 2.8 fölötti verziók esetén 
            a "User Preferences" fül alatt nálam nem jelenik meg a következő opció:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/cudablend.png" format="PNG" scale="50" />
            </imageobject>
        </mediaobject>
        <para>
            Viszont csatolom az általam használt kódot, ami Bátfai Norbert munkája, a matematikai háttere ennek a programnak is megegyezik az előzőleg használt
            programokkal.
        </para>

        <programlisting language="c++">
<![CDATA[
            // Copyright (C) 2019
// Norbert Batfai, batfai.norbert@inf.unideb.hu
// Released under GNU GPLv3

#include <png++/image.hpp>
#include <png++/rgb_pixel.hpp>
#include <sys/times.h>
#include <iostream>

#define SIZE 600
#define ITERATION_LIMIT 32000

// Vegigzongorazza a CUDA a szelesseg x magassag racsot:
__device__ int mandel(int k, int j)
{
	// most eppen a j. sor k. oszlopaban vagyunk

	float a = -2.0, b = .7, c = -1.35, d = 1.35;
	int width = SIZE, height = SIZE, iterationLimit = ITERATION_LIMIT;

	float dx = (b - a) / width;
	float dy = (d - c) / height;
	float reC, imC, reZ, imZ, ujreZ, ujimZ;
	int iteration = 0;

	reC = a + k * dx;
	imC = d - j * dy;
	reZ = 0.0;
	imZ = 0.0;
	iteration = 0;

	while (reZ * reZ + imZ * imZ < 4 && iteration < iterationLimit) {
		ujreZ = reZ * reZ - imZ * imZ + reC;
		ujimZ = 2 * reZ * imZ + imC;
		reZ = ujreZ;
		imZ = ujimZ;

		++iteration;

	}
	return iteration;
}

__global__ void mandelkernel(int *buffer)
{

	int tj = threadIdx.x;
	int tk = threadIdx.y;

	int j = blockIdx.x * 10 + tj;
	int k = blockIdx.y * 10 + tk;

	buffer[j + k * SIZE] = mandel(j, k);

}

void cudamandel(int buffer[SIZE][SIZE])
{

	int *deviceImageBuffer;
	cudaMalloc((void **)&deviceImageBuffer, SIZE * SIZE * sizeof(int));

	dim3 grid(SIZE / 10, SIZE / 10);
	dim3 tgrid(10, 10);
	mandelkernel <<< grid, tgrid >>> (deviceImageBuffer);

	cudaMemcpy(buffer, deviceImageBuffer, SIZE * SIZE * sizeof(int),
		   cudaMemcpyDeviceToHost);
	cudaFree(deviceImageBuffer);

}

int main(int argc, char *argv[])
{

	// Merunk idot (PP 64)
	clock_t delta = clock();
	// Merunk idot (PP 66)
	struct tms tmsbuf1, tmsbuf2;
	times(&tmsbuf1);

	int buffer[SIZE][SIZE];

	cudamandel(buffer);

	png::image < png::rgb_pixel > image(SIZE, SIZE);

	for (int j = 0; j < SIZE; ++j) {
		//sor = j;
		for (int k = 0; k < SIZE; ++k) {
			image.set_pixel(k, j,
					png::rgb_pixel(255 -
						       (255 * buffer[j][k]) /
						       ITERATION_LIMIT,
						       255 -
						       (255 * buffer[j][k]) /
						       ITERATION_LIMIT,
						       255 -
						       (255 * buffer[j][k]) /
						       ITERATION_LIMIT));
		}
	}

	image.write("mandel.png");

	times(&tmsbuf2);
	std::cout << tmsbuf2.tms_utime - tmsbuf1.tms_utime + tmsbuf2.tms_stime -
	    tmsbuf1.tms_stime << std::endl;

	delta = clock() - delta;
	std::cout << (float)delta / CLOCKS_PER_SEC << " sec" << std::endl;

}

        ]]>
        </programlisting>  
        <para> 
            Megoldás videó: <link xlink:href="https://youtu.be/gvaqijHlRUs">https://youtu.be/gvaqijHlRUs</link>
        </para>
        <para>
            Megoldás forrása:                
 <link xlink:href="../../../bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu">
                <filename>bhax/attention_raising/CUDA/mandelpngc_60x60_100.cu</filename>
            </link> nevű állománya.            
        </para>
    </section>                     

    <section>
        <title>Mandelbrot nagyító és utazó C++ nyelven</title>
        <para>
            Építs GUI-t a Mandelbrot algoritmusra, lehessen egérrel nagyítani egy területet, illetve egy pontot
            egérrel kiválasztva vizualizálja onnan a komplex iteréció bejárta z<subscript>n</subscript> komplex számokat!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.       
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Ebben a feladatban olyan programot kellett készíteni amivel már valódi GUI-t (Graphical User Interface)
            is tudunk használni. Ahhoz, hogy egy ilyet lehessen készíteni szükségünk van  Qt Application-re, ez fogja ugyanis 
            a nagyító programunknak a programablakot biztosítani. A Qt-t egyébként nagyon széles körben alkalmazzák, népszerű 
            választás ha GUI-ról van szó. Nézzük, meg hogy hogyan épül fel a program, a nagyítások miatt eléggé összetett 
            tehát nem fogom az egész forrást bemutatni, annak csak bizonyos részeit. 
        </para>
        <para>
            Kezdük a <command>main.cpp</command> nevű fájllal. Ez elég rövidke viszont jó kiindulési pont ha meg akarjuk érteni a programot. 
            ebben láthatjuk, hogy amikor <function>w1</function> objektum létrejön meghívódik a <function>FrakAblak</function> konstruktor és <function>w1.show()</function>
            függvény megjeleníti a programablakot.
        </para>
        <programlisting language="c++">
        <![CDATA[
        #include <QtWidgets/QApplication>
#include "frakablak.h"

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
   
    FrakAblak w1;
    w1.show();
   
    return a.exec();
}
        ]]>
        </programlisting> 
         <para>
            Ezután tekintsük a <command>frakszal.cpp</command> programot. Ebben a programban történik a Mandelbrot halmaz kiszámítása 
            a komplex síkon. Mivel a nagyítások során mindig változik annak a négyzetnek a pozíciója melyet a komplex síkon meg kell jelenítenie 
            programunknak szüksége van az <function>a, b, c ,d</function> értékekre amelyeket a <command>frakablak.cpp</command>-től kap meg. Itt láthatjuk 
            a <function>FrakSzal</function> konstruktor:
        </para>
        <programlisting language="c++">
        <![CDATA[
        #include "frakszal.h"

FrakSzal::FrakSzal(double a, double b, double c, double d,
                   int szelesseg, int magassag, int iteraciosHatar, FrakAblak *frakAblak)
{
    this->a = a;
    this->b = b;
    this->c = c;
    this->d = d;
    this->szelesseg = szelesseg;
    this->iteraciosHatar = iteraciosHatar;
    this->frakAblak = frakAblak;
    this->magassag = magassag;

    egySor = new int[szelesseg];
}
]]></programlisting> 
        <para>
            Ez a 4 sor pedig a <function>FrakSzal</function> destruktora, látszik a "~" jelölésből.
        </para>

        <programlisting language="c++">
        <![CDATA[
FrakSzal::~FrakSzal()
{
    delete[] egySor;
}
]]></programlisting> 
        <para>
            A következő kódcsipet pedig az  iteráció kiszámítását tartalmazza, természetesen a matematikai háttere 
            itt is megegyezik az előző feladatokban megismert programokéval. Ebben a programban ami érdekes, hogy soronként számolja ki a kirajzolandó képet. 
            Az adott sorra eső pixelek <function>iteracio</function> értékét, egy <function>k</function> elemű <function>egySor</function> nevű tömbbe tároljuk. 
            Ha megnézzük a számítást, a két for ciklus közül a belső az ami <function>k</function>-szor, azaz  <function>szelesseg</function> számú hajtódik végre, tehát ezek a megjelenítendő "kép" sorai.
            Figyeljük meg az alábbi sort! 
            <screen>frakAblak->vissza(j, egySor, szelesseg);</screen>
            Itt adja át ugyanis a <function>frakSzal</function> az egy sorban lévő iterációk értékét a <function>frakAblak</function>-nak.
        </para>

<programlisting language="c++">
        <![CDATA[
void FrakSzal::run()
{
    // A [a,b]x[c,d] tartományon milyen sûrû a
    // megadott szélesség, magasság háló:
    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
    
    int iteracio = 0;
    
    for(int j=0; j<magassag; ++j) {
       
        for(int k=0; k<szelesseg; ++k) {
           
            reC = a+k*dx;
            imC = d-j*dy;
            
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            
            while(reZ*reZ + imZ*imZ < 4 && iteracio < iteraciosHatar) {
                // z_{n+1} = z_n * z_n + c

                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;

                reZ = ujreZ;
                imZ = ujimZ;

                ++iteracio;

            }

            iteracio %= 256;

           
            egySor[k] = iteracio;
        }
  
        frakAblak->vissza(j, egySor, szelesseg);
    }
    frakAblak->vissza();

}
        ]]></programlisting> 
        <para>
            Most pedig térjünk át a megjelenítésért felelős <command>frakablak.cpp</command>-re! Először is láthatjuk a 
            <function>FrakAblak</function> konstruktort. Ami 7 paramétert vár, ezek között találjuk az <function>a, b, c ,d</function> értékeket, 
            <function>szelesseg</function>-et, <function>iteraciosHatar</function>-t és a <function>QWidget *parent</function>-et. A program ezen 
            része felelős azért, hogy elindítsa a <function>FrakSzal</function>-lal való komplex számításokat és újraszámításokat.
            <screen>mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
            mandelbrot->start();</screen>
        </para>

        <programlisting language="c++">
        <![CDATA[
        #include <iostream>
#include "frakablak.h"

FrakAblak::FrakAblak(double a, double b, double c, double d,
                     int szelesseg, int iteraciosHatar, QWidget *parent)
                         : QMainWindow(parent)
{
    setWindowTitle("Mandelbrot halmaz");

    szamitasFut = true;
    x = y = mx = my = 0;
    this->a = a;
    this->b = b;
    this->c = c;
    this->d = d;
    this->szelesseg = szelesseg;
    this->iteraciosHatar = iteraciosHatar;
    magassag = (int)(szelesseg * ((d-c)/(b-a)));

    setFixedSize(QSize(szelesseg, magassag));
    fraktal= new QImage(szelesseg, magassag, QImage::Format_RGB32);

    mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
    mandelbrot->start();
}


        ]]></programlisting> 
        <para>
            Láthatjuk a <function>FrakSzal</function>-éhoz hasonló <function>FrakAblak</function> destruktorát.
        </para>
        <programlisting language="c++">
        <![CDATA[
        FrakAblak::~FrakAblak()
{
    delete fraktal;
    delete mandelbrot;
}
        ]]></programlisting> 
        <para>
            Ezután a programunk javarészt osztályonkívűlt deklarált függvényeket tartalmaz, nézzük meg őket sorra! Mivel nagyon hosszú 
            a program nem fogom mindegyik működését részletesen kifejteni, előfordulhat rövid leírást adok róluk.
        </para>
        <para>
            Az első a sorban a <function>paintEvent()</function>, ez rajzolja ki a programablakunkba a képet. Ez a kirajzolás, 
            mint ahogy említettem soronként történik.
        </para>
        <programlisting language="c++">
        <![CDATA[
        void FrakAblak::paintEvent(QPaintEvent*) {
    QPainter qpainter(this);
    qpainter.drawImage(0, 0, *fraktal);
    if(!szamitasFut) {
        qpainter.setPen(QPen(Qt::white, 1));
        qpainter.drawRect(x, y, mx, my);
        if(!zX.empty()) //excuse me
        {
            for(int i=0; i<zX.size(); i++)
            {
                qpainter.drawLine(zX[i],zY[i],zX2[i],zY2[i]);
            }
        }
    }
    qpainter.end();
}
        ]]></programlisting> 
        <para>
            Az következő a <function>mousePressEventEvent()</function>, ez először megvizsgálja, hogy a bal egérgombot 
            nyomtuk-e meg majd ha a feltétel igaz meghatározza az egér pozícióját a programablakban, ez szükséges, ahhoz, hogy amikor nagyítanunk 
            megfelelően tudja kezelni a kattintástól mért kihúzás mértékét, vagyis melyik részére akarunk a komplex síknak nagyítani.
        </para>
        <programlisting language="c++">
        <![CDATA[
        void FrakAblak::mousePressEvent(QMouseEvent* event) {

    if(event->button() == Qt::LeftButton)
    {
    x = event->x();
    y = event->y();
    mx = 0;
    my = 0;
    }
    else if(event->button() == Qt::RightButton)
    {
               double dx = (b-a)/szelesseg;
               double dy = (d-c)/magassag;
               double reC, imC, reZ, imZ, ujreZ, ujimZ;

               int iteracio = 0;

               reC = a+event->x()*dx;
               imC = d-event->y()*dy;

               reZ = 0;
               imZ = 0;
               iteracio = 0;

               while(reZ*reZ + imZ*imZ < 4 && iteracio < 255) {
                   // z_{n+1} = z_n * z_n + c
                   ujreZ = reZ*reZ - imZ*imZ + reC;
                   ujimZ = 2*reZ*imZ + imC;
                   zX.push_back((int)((reZ - a)/dx));
                   zY.push_back( (int)((d - imZ)/dy));
                   zX2.push_back((int)((ujreZ - a)/dx));
                   zY2.push_back((int)((d - ujimZ)/dy));
                   reZ = ujreZ;
                   imZ = ujimZ;

                   ++iteracio;
    }
    }
    update();
}
}
        ]]></programlisting> 
        <para>
            Az egérgombot ha egyszer lenyomtuk azt el is foguk engedni,
            erre szolgál a <function>mouseReleaseEventEvent()</function>, ekkor történik meg az új számítás indítása.
        </para>
        <programlisting language="c++">
        <![CDATA[
        void FrakAblak::mouseReleaseEvent(QMouseEvent* event) {

    if(event->button() == Qt::LeftButton)
    {
    if(szamitasFut)
        return;

    szamitasFut = true;

    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;

    double a = this->a+x*dx;
    double b = this->a+x*dx+mx*dx;
    double c = this->d-y*dy-my*dy;
    double d = this->d-y*dy;

    this->a = a;
    this->b = b;
    this->c = c;
    this->d = d;

    delete mandelbrot;
    mandelbrot = new FrakSzal(a, b, c, d, szelesseg, magassag, iteraciosHatar, this);
    mandelbrot->start();
    }
    update();
}

         ]]></programlisting> 
         <para>
        Ezután a <function>mouseMoveEventEvent()</function> függvénnyel kiszámolunk az egér 2 lekért pozíciójából egy négyzetet ez lesz 
        az új kirajzolandó kép a komplex síkon. 
        </para>
        <programlisting language="c++">
        <![CDATA[
        void FrakAblak::mouseMoveEvent(QMouseEvent* event) {

    // A nagyítandó kijelölt terület szélessége és magassága:
    mx = event->x() - x;
    my = mx; // négyzet alakú

    update();
}
         ]]></programlisting> 
        <para>
        Az utolsó amiről írni szeretnék az alábbi függvény. A harmadik paramétere egy mutatót tartalmaz, ami a memóriában 
        mindig az aktuális kirajzolandó pixel iterációs értékére mutat, tehát innen kapja meg a  <function>FrakAblak</function>
        a <function>FrakSzal</function>-lal kiszámoltatott, tömbben tárol sorait a képnek. Ebben a részben én a színezés miatt 
        módosítottam egy keveset illetve a program minidg kiírja az aktuláis pixel RGB komponenseit. 
        </para>
        <programlisting language="c++">
        <![CDATA[
        void FrakAblak::vissza(int magassag, int *sor, int meret)
{
    int piros = 0;
    int zold = 0;
    int kek = 0;

    for(int i=0; i<meret; ++i) 
    {
        piros = 89 - sor[i];
        zold = 255 - sor[i];
        kek = 89 - sor[i];

        std::cout<< piros << " " << zold << " " << kek << " " << std::endl;

        QRgb szin = qRgb(piros, zold, kek); //qRgb(135, 255-sor[i], 180);//qRgb(piros, kek, zold); //qRgb(0, 255-sor[i], 0);    qRgb(105, 255-sor[i], 180);
        fraktal->setPixel(i, magassag, szin);
    }
    update();
}
        ]]></programlisting> 
        <para>
            Így néz ki a kiszínezett Mandelbrot-halmaz, ha a különböző részeire ránagyítunk:
        </para>
        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/java1.png" format="PNG" scale="20" />
            </imageobject>
        </mediaobject> 

        

    </section> 
                       
                                                                                                                                                                            
    <section>
        <title>Mandelbrot nagyító és utazó Java nyelven</title>
        <para>
            Ebben a feladatban egy Bátfai Norbert által készített és <link xlink:href="https://youtu.be/Ui3B6IJnssY">Czanik András</link> általt módosított 
            forrást dolgozok fel. Mivel az eredti program még nem tudott nagyítani ezért András segítségét kértem. A forráskód logikája szinte ugyanaz mint a C++ verzióé.
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/Ui3B6IJnssY">https://youtu.be/Ui3B6IJnssY</link>, 4:27-től.
            Illetve <link xlink:href="https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal">https://bhaxor.blog.hu/2018/09/02/ismerkedes_a_mandelbrot_halmazzal</link>.
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518">https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/apbs02.html#id570518</link>
        </para>
        <para>
            Itt látható a program matematikai számításokért felelős része a <function>run()</function> függvény, természetesen az iteráció kiszámítához még mindig az előző képletet 
            használtuk.
        </para>

        <programlisting language="java">
        <![CDATA[
        public void run() {

        double dx = (b-a)/szélesség;
        double dy = (d-c)/magasság;
        double reC, imC, reZ, imZ, ujreZ, ujimZ;
        int rgb;
        int iteráció = 0;

        for(int j=0; j<magasság; ++j) {
            sor = j;
            for(int k=0; k<szélesség; ++k) {
                reC = a+k*dx;
                imC = d-j*dy;
                reZ = 0;
                imZ = 0;
                iteráció = 0;

                while(reZ*reZ + imZ*imZ < 4 && iteráció < iterációsHatár) {
                    ujreZ = reZ*reZ - imZ*imZ + reC;
                    ujimZ = 2*reZ*imZ + imC;
                    reZ = ujreZ;
                    imZ = ujimZ;
                    
                    ++iteráció;
                    
                }
                iteráció %= 256;
                rgb = (255-iteráció)|
                        ((255-iteráció) << 8) |
                        ((255-iteráció) << 16);
                kép.setRGB(k, j, rgb);
            }
            repaint();
        }
        számításFut = false;
    }
           ]]></programlisting> 

           <para>
            A kód első része az alábbi, nem a számításokért felelős résszel kezdődik. Ebben a kódcsipetben látható 
            a <function>MandelbrotZoom</function> osztály létrehozási illetve itt tröténik a változók deklarálása is. 
            Mivel a változók neve és szerepe az előző feladatban tárgyalt kóddal szinte pontosan megegyezik ezért nem 
            szeretném bővebben kifejteni. 
        </para>

        <programlisting language="java">
        <![CDATA[
        public class MandelbrotZoom extends java.awt.Frame implements Runnable {

    protected double a, b, c, d;
    protected int szélesség, magasság;
    protected java.awt.image.BufferedImage kép;
    protected int iterációsHatár = 255;
    protected boolean számításFut = false;
    protected int sor = 0;
    protected static int pillanatfelvételSzámláló = 0;

	public static int x;
	public static int y;
	public static int mx;
	public static int my;
           ]]></programlisting> 
        <para>
            Az alábbi <function>addMouseListener</function> rész felel az egérgombok nyomásának vizsgálatáért,
            ez is ugyanúgy működik mint a C++ változatban, tehát ha megnyomjuk a bal egérgombot akkor a 
            az aktuális pozícióját az egérnek az <function>mx</function> <function>my</function> változókba 
            menti el, illetve ebben a kódrészletben találjuk a <function>mouseReleased</function> függvényt is 
            mivel ez is az egér gombnyomásával kapcsolatos műveletekhez tartozik.
        </para>

        <programlisting language="java">
        <![CDATA[
            addMouseListener(new java.awt.event.MouseAdapter() {
			@Override
			public void mousePressed(java.awt.event.MouseEvent me) {
				x = me.getX();
				y = me.getY();
			}

			@Override
			public void mouseReleased(java.awt.event.MouseEvent me) {
				számításFut = true;
				
				double dx = (b - a) / szélesség;
    			double dy = (d - c) / magasság;

				double range = 60;

				double a = MandelbrotZoom.this.a+x*dx;
				double b = MandelbrotZoom.this.a+x*dx+range*dx;
				double c = MandelbrotZoom.this.d-y*dy-range*dy;
				double d = MandelbrotZoom.this.d-y*dy;

				MandelbrotZoom.this.a = a; 
				MandelbrotZoom.this.b = b; 
				MandelbrotZoom.this.c = c; 
				MandelbrotZoom.this.d = d; 

				//new MandelbrotZoom(a, b, c, d, szélesség, magasság);
				new Thread(MandelbrotZoom.this).start();
				//repaint();
			}
		});]]></programlisting> 
        <para>
            Itt pedig a <function>mouseMoved</function> részt láthatjuk, a program itt számolja ki az egér 
            mozgása által megtett utat amivel a nagyítás mértékét tudjuk meghatározni, azaz hogy a komplex 
            síkon vett mely négyzetet szeretnénk a program által megjeleníteni.
        </para>

        <programlisting language="java">
        <![CDATA[
		addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {

            @Override
            public void mouseMoved(java.awt.event.MouseEvent me) {
                int mx = me.getX() - x;
				int my = mx;

				repaint();
            }
        });
           ]]></programlisting> 
        <para>
            A Java és a C++ változatok közti legnagyobb különbség az alábbi függvényben rejlik. Ha megnyomjuk a billentyűzeten az "S" 
            gombot a program egy pillanatképet készít a komplex sík azon részéről amelyiket éppen megjelenítette, mégpedig úgy hogy "rányomtatja"
            az aktuális <function>a, b, c ,d</function> értékeket, és az aktuális iterációshatárt.
        </para>

        <programlisting language="java">
        <![CDATA[
		public void pillanatfelvétel() {
        java.awt.image.BufferedImage mentKép =
                new java.awt.image.BufferedImage(szélesség, magasság,
                java.awt.image.BufferedImage.TYPE_INT_RGB);
        java.awt.Graphics g = mentKép.getGraphics();
        g.drawImage(kép, 0, 0, this);
        g.setColor(java.awt.Color.BLUE);
        g.drawString("a=" + a, 10, 15);
        g.drawString("b=" + b, 10, 30);
        g.drawString("c=" + c, 10, 45);
        g.drawString("d=" + d, 10, 60);
        g.drawString("n=" + iterációsHatár, 10, 75);
        g.dispose();

        StringBuffer sb = new StringBuffer();
        sb = sb.delete(0, sb.length());
        sb.append("MandelbrotZoom_");
        sb.append(++pillanatfelvételSzámláló);
        sb.append("_");
        sb.append(a);
        sb.append("_");
        sb.append(b);
        sb.append("_");
        sb.append(c);
        sb.append("_");
        sb.append(d);
        sb.append(".png");

        try {
            javax.imageio.ImageIO.write(mentKép, "png",
                    new java.io.File(sb.toString()));
        } catch(java.io.IOException e) {
            e.printStackTrace();
        }
    }
           ]]></programlisting> 
             <para>
                Én is készítettem néhány ilyen pillanatfelvételt a programmal, a mentett png-ket itt lehet megtekinteni:
             </para>
             <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/MandelbrotZoom_1_-2.0_0.7_-1.35_1.35.png" format="PNG" scale="40" />
            </imageobject>
        </mediaobject> 
        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/MandelbrotZoom_1_-0.6229999999999998_-0.35299999999999976_0.36_0.63.png" format="PNG" scale="40" />
            </imageobject>
        </mediaobject> 
        <mediaobject>
            <imageobject>
                <imagedata fileref ="./img/MandelbrotZoom_1_-0.3664999999999998_-0.09649999999999981_0.504_0.774.png" format="PNG" scale="40" />
            </imageobject>
        </mediaobject> 
    </section>

    <section>
        <title>Vörös pipacs pokol/fel a láváig és vissza</title>
        <para>
            Ebbn a feladatban tutoriáltam volt Papp Csenge.
        </para>
        <para>
            <link xlink:href="https://www.youtube.com/watch?v=zO6cNp8L4-Q">Megoldás videó</link>
        </para>

        <para>
            Mivel ahogy már korábban említettem egy összetettebb feladat megoldást szedel szét kisebb darabokra. 
            A feladat lényegi része a következő. Stevnek Fel kell szaladnia az arénában ameddig csak tud, azaz amíg nem találkozik lávával. 
            Ezt úgy oldottuk meg, hogy Steve alap mozága 2 <function>move 1</function>-ből és egy<function>jumpmove 1</function>-ből áll. 
            Azaz egy adott szinten megtesz két lépést majd ugrik minidg a következőre egészen addig amíg lávát nem érzékel.
        </para>

        <programlisting language="python">
        <![CDATA[   
                self.agent_host.sendCommand( "move 1" )
                time.sleep(0.01)
                self.agent_host.sendCommand( "move 1" )
                time.sleep(0.01)
                if escape == 0:
                    self.agent_host.sendCommand( "jumpmove 1" )
                    time.sleep(0.5)
           ]]></programlisting> 
           <para>
            A láva érzékelését egy 3x3x3-mas cuboid segítségével oldottuk meg. A cuboudot amit lát Steve egy 27 elemet tartalmazó tömbként értelmezhetjük, 
            egy for ciklussal megvizsgáljuk annak minden elemét, hogy a tömb éppen tartalmaz-e "lava"-t vagy "flowing_lava"-t. Amennyiben erre a válasz igen 
            Steve 180 fokos fordulatot vesz és leszalad az aréna aljába, innen fogja elkezdeni a csiga mozgását.
        </para>
           <programlisting language="python">
        <![CDATA[
		for i in range(27):
                    if nbr3x3x3[i] == "flowing_lava" or nbr3x3x3[i] == "lava":
                        print("     Lavaaaa!")
                        if escape == 0:
                            self.agent_host.sendCommand( "turn -1" )
                            time.sleep(0.01)
                            self.agent_host.sendCommand( "turn -1" )
                            time.sleep(0.01)
                        escape = 1 #ez az escape igaz hamis hogy kell-e menekülni, akkor már nem ugrik csak fut meg ne forogjon 
           ]]></programlisting> 


    </section>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
